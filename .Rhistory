for (i in 1:length(sea.level)){
damage.values[i] <- damage.calc(sea.level[i])*1e6
}
damage.values.w.barrier <- rep(0, length(sea.level) +1) #len = 21
for (i in 1:length(sea.level)){
damage.values.w.barrier[i] <- damage.calc.w.barrier(sea.level[i])*1e6
}
#steps between the years
dx <- seq(from = 0 , to = 20, by = 1) #len = 21
#calculating the avergae value of damage w and w/o barrier
avg.w.barrier <- sum(damage.values.w.barrier*new.vals.barrier*dx)
avg.wo.barrier <- sum(damage.values*new.vals.no.barrier*dx)
#calculating flood damage overall w and w/o barrier
flood.damage.no.barrier <- avg.wo.barrier * prob.of.flood[5e4:niter,]
flood.damage.w.barrier <- avg.w.barrier * prob.of.flood.barrier[5e4:niter,] + initial.build.cost + upkeep.cost
#compare the values now to determine whether to build or not to build
#if it is neg or positive - can tell us whether to build or not build
#new.stuff <- flood.damage.no.barrier - flood.damage.w.barrier
#time <- 90001
#array <- matrix(ncol = 2, nrow = time)
#find the average values of damage costs for each iteration
avg.damage.no.barrier <- apply(flood.damage.no.barrier, 1, mean)
avg.damage.w.barrier <- apply(flood.damage.w.barrier, 1, mean)
#use which to find the number of places where we should and shouldnt build
should.build <- which(avg.damage.w.barrier < avg.damage.no.barrier)
shouldnt.build <- which(avg.damage.no.barrier < avg.damage.w.barrier)
regret.vals <- rep(0, length(avg.damage.no.barrier))
if (length(should.build) > length(shouldnt.build)){
#we will be building - now need to calculate regret of the no build values
for (i in 1:length(shouldnt.build)){
regret.vals[i] <- abs(avg.damage.no.barrier[shouldnt.build[i]] - avg.damage.w.barrier[shouldnt.build[i]])
}
}else{
for (i in 1:length(should.build)){
regret.vals[i] <- abs(avg.damage.no.barrier[should.build[i]] - avg.damage.w.barrier[should.build[i]])
}
#regret.vals[i] <- abs(avg.damage.no.barrier[should.build[i]] - avg.damage.w.barrier[should.build[i]])
}
regret.calc.out <- vector('list', 7)
names(regret.calc.out) <- c('no.barrier', 'w.barrier', 'regret.array', 'should.build', 'shouldnt.build', 'avg.no.barrier','avg.w.barrier')
regret.calc.out$no.barrier <- flood.damage.no.barrier[,1:20]
regret.calc.out$w.barrier <- flood.damage.w.barrier[,1:20]
regret.calc.out$regret.array <- regret.vals
regret.calc.out$should.build <- should.build
regret.calc.out$shouldnt.build <- shouldnt.build
regret.calc.out$avg.no.barrier <- avg.damage.no.barrier
regret.calc.out$avg.w.barrier <- avg.damage.w.barrier
return(regret.calc.out)
}
regret.stationary <- regret.calculator(niter = niter,
years = years,
effect.height.no.barrier = effect.height.no.barrier,
effect.height.barrier=effect.height.barrier,
slr=slr,
mcmc.chain = test1 ,
n.params = 3,
param.names = param.names,
temps = temp.vals)
hist(regret.stationary$regret.array)
regret.stationary$no.barrier
regret.stationary$w.barrier
sigma.nonstat <- mcmc.sigma.nonstat.parallel[[1]]$samples
param.names <- c('mu', 'sigma0', 'sigma1', 'xi')
regret.sigma.nonstationary <- regret.calculator(niter = niter,
years = years,
effect.height.no.barrier = effect.height.no.barrier,
effect.height.barrier=effect.height.barrier,
slr=slr,
mcmc.chain = sigma.nonstat,
n.params = 4,
param.names = param.names,
temps = temp.vals)
hist(regret.sigma.nonstationary$regret.array)
regret.sigma.nonstationary$no.barrier
regret.sigma.nonstationary$w.barrier
regret.stationary$w.barrier
regret.stationary$no.barrier
devd.calculator <- function(p, param.names, temperature, data){
n.parnames <- length( param.names)
#checks length of parameters, which will be used to determine which parameters are non stationary
#if all parameters are stationary
if (n.parnames == 3){
mu <- p[1]
sigma <- p[2]
xi <- p[3]
#print('here')
}
#one stationary parameter
else if(n.parnames ==4){
if (param.names[1] == 'mu0'){
mu0 <- p[1]
mu1 <- p[2]
sigma <- p[3]
xi <- p[4]
mu <- mu0 + mu1*temperature
}
else if (param.names[2] == 'sigma0'){
mu <- p[1]
sigma0 <- p[2]
sigma1 <- p[3]
xi <- p[4]
sigma <- exp(sigma0+ sigma1*temperature)
}
else{
mu <- p[1]
sigma <- p[2]
xi0 <- p[3]
xi1 <- p[4]
xi <- xi0 + xi1*temperature
}
}
#two stationary parameters
else if (n.parnames == 5){
if (param.names[1] == 'mu0' & param.names[3]=='sigma0'){
mu0 <- p[1]
mu1 <- p[2]
sigma0 <- p[3]
sigma1 <- p[4]
xi <- p[5]
mu <- mu0 + mu1*temperature
sigma <- exp(sigma0 + sigma1*temperature)
}
else if(param.names[2] == 'sigma0' & param.names[4] == 'xi0'){
mu <- p[1]
sigma0 <- p[2]
sigma1 <- p[3]
xi0 <- p[4]
xi1 <- p[5]
sigma <- exp(sigma0 + sigma1*temperature)
xi <- xi0 + xi1*temperature
}
else{
mu0 <- p[1]
mu1 <- p[2]
sigma <- p[3]
xi0 <- p[4]
xi1 <- p[5]
mu <- mu0 + mu1*temperature
xi <- xi0 + xi1*temperature
}
}
#all parameters non stationary
else if (n.parnames ==6){
mu0 <- p[1]
mu1 <- p[2]
sigma0 <- p[3]
sigma1 <- p[4]
xi0 <- p[5]
xi1 <- p[6]
mu <- mu0 + mu1*temperature # I think it is freaking out because it doesn't know what temperature to use here well....
sigma <- exp(sigma0 + sigma1*temperature)
xi <- xi0 + xi1*temperature
}
val <- sum(devd(data, loc = mu , scale = sigma, shape = xi, type=c('GEV')))
return(val)
}
pevd.calculator <- function(p, param.names, temperature, data.pt){
n.parnames <- length(param.names)
#checks length of parameters, which will be used to determine which parameters are non stationary
#if all parameters are stationary
if (n.parnames == 3){
mu <- p[1]
sigma <- p[2]
xi <- p[3]
#print('here1')
}
#one stationary parameter
else if(n.parnames ==4){
if (param.names[1] == 'mu0'){
mu0 <- p[1]
mu1 <- p[2]
sigma <- p[3]
xi <- p[4]
# print('here1')
mu <- mu0 + mu1*temperature
}
else if (param.names[2] == 'sigma0'){
mu <- p[1]
sigma0 <- p[2]
sigma1 <- p[3]
xi <- p[4]
# print('here2')
sigma <- exp(sigma0+ sigma1*temperature)
}
else{
mu <- p[1]
sigma <- p[2]
xi0 <- p[3]
xi1 <- p[4]
#print('here2')
xi <- xi0 + xi1*temperature
}
}
#two stationary parameters
else if (n.parnames == 5){
if (param.names[1] == 'mu0' & param.names[3]=='sigma0'){
mu0 <- p[1]
mu1 <- p[2]
sigma0 <- p[3]
sigma1 <- p[4]
xi <- p[5]
#print('here4')
mu <- mu0 + mu1*temperature
sigma <- exp(sigma0 + sigma1*temperature)
}
else if(parnames[2] == 'sigma0' &param.names[4] == 'xi0'){
mu <- p[1]
sigma0 <- p[2]
sigma1 <- p[3]
xi0 <- p[4]
xi1 <- p[5]
sigma <- exp(sigma0 + sigma1*temperature)
xi <- xi0 + xi1*temperature
}
else{
mu0 <- p[1]
mu1 <- p[2]
sigma <- p[3]
xi0 <- p[4]
xi1 <- p[5]
mu <- mu0 + mu1*temperature
xi <- xi0 + xi1*temperature
}
}
#all parameters non stationary
else if (n.parnames ==6){
mu0 <- p[1]
mu1 <- p[2]
sigma0 <- p[3]
sigma1 <- p[4]
xi0 <- p[5]
xi1 <- p[6]
mu <- mu0 + mu1*temperature # I think it is freaking out because it doesn't know what temperature to use here well....
sigma <- exp(sigma0 + sigma1*temperature)
xi <- xi0 + xi1*temperature
}
val <- 1 - pevd(data.pt, loc = mu , scale = sigma, shape = xi, type=c('GEV'))
return(val)
}
sigma.nonstat <- mcmc.sigma.nonstat.parallel[[1]]$samples
param.names <- c('mu', 'sigma0', 'sigma1', 'xi')
regret.sigma.nonstationary <- regret.calculator(niter = niter,
years = years,
effect.height.no.barrier = effect.height.no.barrier,
effect.height.barrier=effect.height.barrier,
slr=slr,
mcmc.chain = sigma.nonstat,
n.params = 4,
param.names = param.names,
temps = temp.vals)
regret.sigma.nonstationary$regret.array
hist(regret.sigma.nonstationary$regret.array)
regret.sigma.nonstationary$no.barrier
hist(regret.stationary$avg.no.barrier)
hist(regret.stationary$avg.w.barrier)
damage.calc(tmp[10])
damage.calc(tmp[10])*1e6
tmp[10]
damage.calc(5)
damage.calc.w.barrier(5)
flood.damage.no.barrier <- avg.wo.barrier * prob.of.flood[5e4:niter,]
flood.damage.w.barrier <- avg.w.barrier * prob.of.flood.barrier[5e4:niter,] + initial.build.cost + upkeep.cost
flood.damage.no.barrier
avg.wo.barrier
prob.of.flood[5e4:niter,]
prob.of.flood[5e4]
dim(prob.of.flood)
prob.of.flood <- matrix(ncol = length(years), nrow = niter)
pb <- txtProgressBar(min=0,max=niter,initial=0,style=3)
for(i in 5e4:niter){ #cutting off the start before convergence , need temp prediction of the future
for (t in 1:21){
prob.of.flood[i,t] <- pevd.calculator(p=mcmc.chain[i,], param.names=param.names, temps[t], data.pt=hgt.changing[t])
}
setTxtProgressBar(pb, i)
}
close(pb)
hgt.changing <- effect.height.no.barrier - length(years)*slr
hgt.barrier.changing <- effect.height.barrier - length(years)*slr
hgt.changing
hgt.barrier.changing
lower.level <- effect.height.no.barrier - 21*slr
lower.level.barrier <- effect.height.barrier - 21*slr
hgt.changing <- seq(from = effect.height.no.barrier, to = lower.level, by = -slr )
hgt.barrier.changing <- seq(from = effect.height.barrier, to = lower.level.barrier, by = -slr)
regret.calculator <- function(niter,
years,
effect.height.no.barrier,
effect.height.barrier,
slr,
mcmc.chain,
n.params,
param.names,
temps
){ #niter = number iterations (int), years - sequence of years to cover,
#prob of a certain flood happening                    #effect.height.no.barrier (height in mm of no damage area)
#effect.height.barrier (height in mm of no damage area w barrier present)
#slr, rate at which sea level is changing in the particular area
#change in effective height over course of years
#lower.level <- effect.height.no.barrier - 21*slr
#lower.level.barrier <- effect.height.barrier - 21*slr
# hgt.changing <- effect.height.no.barrier - length(years)*slr
#hgt.barrier.changing <- effect.height.barrier - length(years)*slr
hgt.changing <- seq(from = 2850, to = 2808, by = -2 ) #this is hard coded at the moment to try to get it to work
hgt.barrier.changing <- seq(from = 3280, to = 3238, by = -2)
#calculate cdf of flooding w no barrier and sea level
#temp included if non stationary
prob.of.flood <- matrix(ncol = length(years), nrow = niter)
pb <- txtProgressBar(min=0,max=niter,initial=0,style=3)
for(i in 5e4:niter){ #cutting off the start before convergence , need temp prediction of the future
for (t in 1:21){
prob.of.flood[i,t] <- pevd.calculator(p=mcmc.chain[i,], param.names=param.names, temps[t], data.pt=hgt.changing[t])
}
setTxtProgressBar(pb, i)
}
close(pb)
#calculate cdf of flooding w barrier present and sea level rise
#temp included if non stationary
prob.of.flood.barrier <- matrix(ncol = length(years), nrow = niter)
pb <- txtProgressBar(min=0,max=niter,initial=0,style=3)
for(i in 5e4:niter){
for (t in 1:21){
prob.of.flood.barrier[i,t] <- pevd.calculator(p=mcmc.chain[i,], param.names=param.names, temps[t], data.pt=hgt.barrier.changing[t])
}
setTxtProgressBar(pb, i)
}
#calculating the gev of each set of parameters - w barrier
for (t in 1:21){
new.vals.barrier[t] <- devd.calculator(p= mcmc.chain[i,], param.names = param.names, temps[t], data = hgt.barrier.changing)
}
#no barrier
for (t in 1:21){
new.vals.no.barrier[t] <- devd.calculator( p= mcmc.chain[i,], param.names = param.names, temps[t], data = hgt.changing)
}
#calculating damage at each height on the spectrum (0 to 4.75m)
sea.level <- seq(from=0, to = 5.0, by = .25) #len = 20
damage.values <- rep(0, length(sea.level) + 1) #len = 20
for (i in 1:length(sea.level)){
damage.values[i] <- damage.calc(sea.level[i])*1e6
}
damage.values.w.barrier <- rep(0, length(sea.level) +1) #len = 21
for (i in 1:length(sea.level)){
damage.values.w.barrier[i] <- damage.calc.w.barrier(sea.level[i])*1e6
}
#steps between the years
dx <- seq(from = 0 , to = 20, by = 1) #len = 21
#calculating the avergae value of damage w and w/o barrier
avg.w.barrier <- sum(damage.values.w.barrier*new.vals.barrier*dx)
avg.wo.barrier <- sum(damage.values*new.vals.no.barrier*dx)
#calculating flood damage overall w and w/o barrier
flood.damage.no.barrier <- avg.wo.barrier * prob.of.flood[5e4:niter,]
flood.damage.w.barrier <- avg.w.barrier * prob.of.flood.barrier[5e4:niter,] + initial.build.cost + upkeep.cost
#compare the values now to determine whether to build or not to build
#if it is neg or positive - can tell us whether to build or not build
#new.stuff <- flood.damage.no.barrier - flood.damage.w.barrier
#time <- 90001
#array <- matrix(ncol = 2, nrow = time)
#find the average values of damage costs for each iteration
avg.damage.no.barrier <- apply(flood.damage.no.barrier, 1, mean)
avg.damage.w.barrier <- apply(flood.damage.w.barrier, 1, mean)
#use which to find the number of places where we should and shouldnt build
should.build <- which(avg.damage.w.barrier < avg.damage.no.barrier)
shouldnt.build <- which(avg.damage.no.barrier < avg.damage.w.barrier)
regret.vals <- rep(0, length(avg.damage.no.barrier))
if (length(should.build) > length(shouldnt.build)){
#we will be building - now need to calculate regret of the no build values
for (i in 1:length(shouldnt.build)){
regret.vals[i] <- abs(avg.damage.no.barrier[shouldnt.build[i]] - avg.damage.w.barrier[shouldnt.build[i]])
}
}else{
for (i in 1:length(should.build)){
regret.vals[i] <- abs(avg.damage.no.barrier[should.build[i]] - avg.damage.w.barrier[should.build[i]])
}
#regret.vals[i] <- abs(avg.damage.no.barrier[should.build[i]] - avg.damage.w.barrier[should.build[i]])
}
regret.calc.out <- vector('list', 7)
names(regret.calc.out) <- c('no.barrier', 'w.barrier', 'regret.array', 'should.build', 'shouldnt.build', 'avg.no.barrier','avg.w.barrier')
regret.calc.out$no.barrier <- flood.damage.no.barrier[,1:20]
regret.calc.out$w.barrier <- flood.damage.w.barrier[,1:20]
regret.calc.out$regret.array <- regret.vals
regret.calc.out$should.build <- should.build
regret.calc.out$shouldnt.build <- shouldnt.build
regret.calc.out$avg.no.barrier <- avg.damage.no.barrier
regret.calc.out$avg.w.barrier <- avg.damage.w.barrier
return(regret.calc.out)
}
param.names <- c('mu', 'sigma', 'xi')
test1 <- mcmc.test.stationary.parallel[[1]]$samples
regret.stationary <- regret.calculator(niter = niter,
years = years,
effect.height.no.barrier = effect.height.no.barrier,
effect.height.barrier=effect.height.barrier,
slr=slr,
mcmc.chain = test1 ,
n.params = 3,
param.names = param.names,
temps = temp.vals)
hist(regret.stationary$regret.array)
regret.stationary$regret.array
hist(regret.stationary$no.barrier)
hist(regret.stationary$w.barrier)
regret.calculator <- function(niter,
years,
effect.height.no.barrier,
effect.height.barrier,
slr,
mcmc.chain,
n.params,
param.names,
temps
){ #niter = number iterations (int), years - sequence of years to cover,
#prob of a certain flood happening                    #effect.height.no.barrier (height in mm of no damage area)
#effect.height.barrier (height in mm of no damage area w barrier present)
#slr, rate at which sea level is changing in the particular area
#change in effective height over course of years
#lower.level <- effect.height.no.barrier - 21*slr
#lower.level.barrier <- effect.height.barrier - 21*slr
# hgt.changing <- effect.height.no.barrier - length(years)*slr
#hgt.barrier.changing <- effect.height.barrier - length(years)*slr
hgt.changing <- seq(from = 2850, to = 2808, by = -2 ) #this is hard coded at the moment to try to get it to work
hgt.barrier.changing <- seq(from = 3280, to = 3238, by = -2)
#calculate cdf of flooding w no barrier and sea level
#temp included if non stationary
prob.of.flood <- matrix(ncol = length(years), nrow = niter)
pb <- txtProgressBar(min=0,max=niter,initial=0,style=3)
for(i in 5e4:niter){ #cutting off the start before convergence , need temp prediction of the future
for (t in 1:21){
prob.of.flood[i,t] <- pevd.calculator(p=mcmc.chain[i,], param.names=param.names, temps[t], data.pt=hgt.changing[t])
}
setTxtProgressBar(pb, i)
}
close(pb)
#calculate cdf of flooding w barrier present and sea level rise
#temp included if non stationary
prob.of.flood.barrier <- matrix(ncol = length(years), nrow = niter)
pb <- txtProgressBar(min=0,max=niter,initial=0,style=3)
for(i in 5e4:niter){
for (t in 1:21){
prob.of.flood.barrier[i,t] <- pevd.calculator(p=mcmc.chain[i,], param.names=param.names, temps[t], data.pt=hgt.barrier.changing[t])
}
setTxtProgressBar(pb, i)
}
#calculating the gev of each set of parameters - w barrier
for (t in 1:21){
new.vals.barrier[t] <- devd.calculator(p= mcmc.chain[i,], param.names = param.names, temps[t], data = hgt.barrier.changing)
}
#no barrier
for (t in 1:21){
new.vals.no.barrier[t] <- devd.calculator( p= mcmc.chain[i,], param.names = param.names, temps[t], data = hgt.changing)
}
#calculating damage at each height on the spectrum (0 to 4.75m)
sea.level <- seq(from=0, to = 5.0, by = .25) #len = 20
damage.values <- rep(0, length(sea.level) + 1) #len = 20
for (i in 1:length(sea.level)){
damage.values[i] <- damage.calc(sea.level[i])*1e6
}
damage.values.w.barrier <- rep(0, length(sea.level) +1) #len = 21
for (i in 1:length(sea.level)){
damage.values.w.barrier[i] <- damage.calc.w.barrier(sea.level[i])*1e6
}
#steps between the years
dx <- seq(from = 0 , to = 20, by = 1) #len = 21
#calculating the avergae value of damage w and w/o barrier
avg.w.barrier <- sum(damage.values.w.barrier*new.vals.barrier) #took out dx temporarily
avg.wo.barrier <- sum(damage.values*new.vals.no.barrier)
#calculating flood damage overall w and w/o barrier
flood.damage.no.barrier <- avg.wo.barrier * prob.of.flood[5e4:niter,]
flood.damage.w.barrier <- avg.w.barrier * prob.of.flood.barrier[5e4:niter,] + initial.build.cost + upkeep.cost
#compare the values now to determine whether to build or not to build
#if it is neg or positive - can tell us whether to build or not build
#new.stuff <- flood.damage.no.barrier - flood.damage.w.barrier
#time <- 90001
#array <- matrix(ncol = 2, nrow = time)
#find the average values of damage costs for each iteration
avg.damage.no.barrier <- apply(flood.damage.no.barrier, 1, mean)
avg.damage.w.barrier <- apply(flood.damage.w.barrier, 1, mean)
#use which to find the number of places where we should and shouldnt build
should.build <- which(avg.damage.w.barrier < avg.damage.no.barrier)
shouldnt.build <- which(avg.damage.no.barrier < avg.damage.w.barrier)
regret.vals <- rep(0, length(avg.damage.no.barrier))
if (length(should.build) > length(shouldnt.build)){
#we will be building - now need to calculate regret of the no build values
for (i in 1:length(shouldnt.build)){
regret.vals[i] <- abs(avg.damage.no.barrier[shouldnt.build[i]] - avg.damage.w.barrier[shouldnt.build[i]])
}
}else{
for (i in 1:length(should.build)){
regret.vals[i] <- abs(avg.damage.no.barrier[should.build[i]] - avg.damage.w.barrier[should.build[i]])
}
#regret.vals[i] <- abs(avg.damage.no.barrier[should.build[i]] - avg.damage.w.barrier[should.build[i]])
}
regret.calc.out <- vector('list', 7)
names(regret.calc.out) <- c('no.barrier', 'w.barrier', 'regret.array', 'should.build', 'shouldnt.build', 'avg.no.barrier','avg.w.barrier')
regret.calc.out$no.barrier <- flood.damage.no.barrier[,1:20]
regret.calc.out$w.barrier <- flood.damage.w.barrier[,1:20]
regret.calc.out$regret.array <- regret.vals
regret.calc.out$should.build <- should.build
regret.calc.out$shouldnt.build <- shouldnt.build
regret.calc.out$avg.no.barrier <- avg.damage.no.barrier
regret.calc.out$avg.w.barrier <- avg.damage.w.barrier
return(regret.calc.out)
}
regret.stationary <- regret.calculator(niter = niter,
years = years,
effect.height.no.barrier = effect.height.no.barrier,
effect.height.barrier=effect.height.barrier,
slr=slr,
mcmc.chain = test1 ,
n.params = 3,
param.names = param.names,
temps = temp.vals)
hist(regret.stationary$regret.array)
regret.stationary$regret.array
